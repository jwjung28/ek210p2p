/*
  IR Morse Receiver + Decoder + LCD display
  - RX (demodulated 38 kHz) on D4
  - LCD I2C: SDA=A4, SCL=A5, address 0x27 (change if needed)

  What it does:
    * Measures "mark" (carrier present) and "gap" (no carrier) durations
    * Classifies marks into dot (·) or dash (–)
    * Uses gap lengths to decide element/letter/word boundaries
    * Prints raw Morse (e.g., ".-") and decoded char to Serial
    * Shows decoded text on LCD second line

  Tip: Keep transmitter and receiver UNIT_MS similar (here 120 ms).
*/

#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// ---------- Hardware config ----------
const uint8_t  RX_PIN     = 4;     // demodulated receiver output
const bool     ACTIVE_LOW = true;  // true: LOW = carrier present (typical TSOP/VS1838)

// ---------- Morse timing (tweak to taste) ----------
const uint16_t UNIT_MS     = 120;                   // base time unit
const uint32_t UNIT_US     = (uint32_t)UNIT_MS * 1000UL;
const uint32_t DOT_MAX_US  = (uint32_t)(1.5 * UNIT_US);  // <= 1.5u => DOT
const uint32_t INTRA_MAX_US= (uint32_t)(1.5 * UNIT_US);  // <= 1.5u gap => between elements
const uint32_t LETTER_MIN_US = (uint32_t)(2.5 * UNIT_US);// >= 2.5u gap => letter boundary
const uint32_t WORD_MIN_US   = (uint32_t)(6.5 * UNIT_US);// >= 6.5u gap => word boundary

// If no edges happen for this long while in gap, finalize a letter
const uint32_t LETTER_TIMEOUT_US = LETTER_MIN_US;

// ---------- LCD ----------
LiquidCrystal_I2C lcd(0x27, 16, 2);  // change 0x27 -> 0x3F if needed

// ---------- State for edge timing ----------
bool prevLevel = false;            // "carrier present" level last loop
uint32_t lastChangeUs = 0;         // time of last level change (micros)
String currentSymbol = "";         // accumulating "." and "-" for one letter
String lineBuffer = "";            // decoded text to show on LCD 2nd line

// ---------- Morse table ----------
struct MorseEntry { const char* code; char ch; };

const MorseEntry MORSE_TABLE[] = {
  // Letters
  {".-", 'A'}, {"-...", 'B'}, {"-.-.", 'C'}, {"-..", 'D'}, {".", 'E'},
  {"..-.", 'F'}, {"--.", 'G'}, {"....", 'H'}, {"..", 'I'}, {".---", 'J'},
  {"-.-", 'K'}, {".-..", 'L'}, {"--", 'M'}, {"-.", 'N'}, {"---", 'O'},
  {".--.", 'P'}, {"--.-", 'Q'}, {".-.", 'R'}, {"...", 'S'}, {"-", 'T'},
  {"..-", 'U'}, {"...-", 'V'}, {".--", 'W'}, {"-..-", 'X'}, {"-.--", 'Y'}, {"--..", 'Z'},
  // Digits
  {"-----", '0'}, {".----", '1'}, {"..---", '2'}, {"...--", '3'}, {"....-", '4'},
  {".....", '5'}, {"-....", '6'}, {"--...", '7'}, {"---..", '8'}, {"----.", '9'},
  // Punctuation (optional examples)
  {".-.-.-", '.'}, {"--..--", ','}, {"..--..", '?'}, {".----.", '\''}, {"-.-.--", '!'},
  {"-..-.", '/'}, {"-.--.", '('}, {"-.--.-", ')'}, {".-...", '&'}, {"---...", ':'},
  {"-.-.-.", ';'}, {"-...-", '='}, {".-.-.", '+'}, {"-....-", '-'}, {"..--.-", '_'},
  {".-..-.", '\"'}, {".--.-.", '@'}
};
const size_t MORSE_TABLE_SIZE = sizeof(MORSE_TABLE) / sizeof(MorseEntry);

// ---------- Helpers ----------
char decodeMorse(const String& code) {
  for (size_t i = 0; i < MORSE_TABLE_SIZE; ++i) {
    if (code.equals(MORSE_TABLE[i].code)) return MORSE_TABLE[i].ch;
  }
  return '?'; // unknown pattern
}

void appendToLCD(char c) {
  // Keep a simple 16-char line; scroll left when full
  if (c == '\n') {
    lineBuffer = "";
  } else {
    lineBuffer += c;
    if (lineBuffer.length() > 16) {
      lineBuffer.remove(0, lineBuffer.length() - 16);
    }
  }
  lcd.setCursor(0, 0);
  lcd.print("Morse RX:       ");
  lcd.setCursor(0, 1);
  // pad to clear tail
  String padded = lineBuffer;
  while (padded.length() < 16) padded += ' ';
  lcd.print(padded);
}

void finishLetter() {
  if (currentSymbol.length() == 0) return;
  char ch = decodeMorse(currentSymbol);

  // Serial: show raw code and decoded char
  Serial.print("Letter: ");
  Serial.print(currentSymbol);
  Serial.print(" -> ");
  Serial.println(ch);

  appendToLCD(ch);
  currentSymbol = "";
}

void insertSpace() {
  // End any in-progress letter first
  finishLetter();
  Serial.println("Word gap");
  appendToLCD(' ');
}

// ---------- Setup / Loop ----------
void setup() {
  Serial.begin(115200);

  pinMode(RX_PIN, INPUT_PULLUP); // for open-collector style receivers

  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Morse RX:");
  lcd.setCursor(0, 1); lcd.print("Waiting...      ");

  // Initialize state
  lastChangeUs = micros();
  bool raw = digitalRead(RX_PIN);
  prevLevel = (ACTIVE_LOW ? (raw == LOW) : (raw == HIGH)); // "carrier present" boolean

  Serial.println("Morse IR receiver/decoder ready.");
  Serial.print("UNIT_MS="); Serial.println(UNIT_MS);
}

void loop() {
  const uint32_t nowUs = micros();
  const bool raw = digitalRead(RX_PIN);
  const bool level = (ACTIVE_LOW ? (raw == LOW) : (raw == HIGH)); // true = carrier present

  if (level != prevLevel) {
    // An edge occurred; measure the duration of the previous state
    const uint32_t durUs = nowUs - lastChangeUs;

    if (prevLevel) {
      // We were in a MARK (carrier present) -> classify as DOT or DASH
      if (durUs <= DOT_MAX_US) {
        currentSymbol += '.';
        Serial.println("DOT");
      } else {
        currentSymbol += '-';
        Serial.println("DASH");
      }
    } else {
      // We were in a GAP (no carrier)
      if (durUs >= WORD_MIN_US) {
        // Word boundary (≥ 7 units)
        insertSpace();
      } else if (durUs >= LETTER_MIN_US) {
        // Letter boundary (≥ 3 units)
        finishLetter();
      } else {
        // Intra-character gap (~1 unit) -> do nothing
      }
    }

    // Update edge tracking
    prevLevel = level;
    lastChangeUs = nowUs;
  } else {
    // No edge; consider timeouts while in GAP to finalize a letter
    if (!level) { // in GAP
      const uint32_t gapUs = nowUs - lastChangeUs;
      if (gapUs >= WORD_MIN_US) {
        insertSpace();
        // move the boundary so we don't keep inserting spaces
        lastChangeUs = nowUs - WORD_MIN_US + LETTER_MIN_US; // nudge to prevent repeats
      } else if (gapUs >= LETTER_TIMEOUT_US && currentSymbol.length() > 0) {
        finishLetter();
        // avoid re-finishing the same letter repeatedly
        lastChangeUs = nowUs - LETTER_TIMEOUT_US + (UNIT_US / 4);
      }
    }
  }

  // (Optional) small delay to reduce CPU load; keep resolution fine enough for UNIT_MS
  delay(1);
}
