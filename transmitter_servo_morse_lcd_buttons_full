// ==== Combined: Morse TX (buttons) + Servo nudge (±5°) + LCD pattern/char display ====
// Pins: IR=D3, DOT=D4, DASH=D5, LEFT=D6, RIGHT=D7, SERVO=D9, I2C LCD on SDA=A4/SCL=A5 (0x27)

#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Servo.h>

// ---------------- IR / Morse ----------------
const uint8_t  TX_PIN      = 3;         // tone() capable
const uint16_t CARRIER_HZ  = 38000;     // 38 kHz
const uint16_t UNIT_MS     = 120;       // match receiver timing

// Morse input buttons (to GND, INPUT_PULLUP)
const uint8_t DOT_PIN      = 4;
const uint8_t DASH_PIN     = 5;

// End-of-character idle gap
const uint32_t END_CHAR_IDLE_MS = 2000; // >2s => finalize

// Debounce (Morse)
const uint16_t DEBOUNCE_MS_MORSE = 20;

// Morse table
struct MorseEntry { const char* code; char ch; };
const MorseEntry MORSE_TABLE[] = {
  // Letters
  {".-", 'A'}, {"-...", 'B'}, {"-.-.", 'C'}, {"-..", 'D'}, {".", 'E'},
  {"..-.", 'F'}, {"--.", 'G'}, {"....", 'H'}, {"..", 'I'}, {".---", 'J'},
  {"-.-", 'K'}, {".-..", 'L'}, {"--", 'M'}, {"-.", 'N'}, {"---", 'O'},
  {".--.", 'P'}, {"--.-", 'Q'}, {".-.", 'R'}, {"...", 'S'}, {"-", 'T'},
  {"..-", 'U'}, {"...-", 'V'}, {".--", 'W'}, {"-..-", 'X'}, {"-.--", 'Y'}, {"--..", 'Z'},
  // Digits
  {"-----", '0'}, {".----", '1'}, {"..---", '2'}, {"...--", '3'}, {"....-", '4'},
  {".....", '5'}, {"-....", '6'}, {"--...", '7'}, {"---..", '8'}, {"----.", '9'}
};
const size_t MORSE_TABLE_SIZE = sizeof(MORSE_TABLE) / sizeof(MorseEntry);

// Carrier helpers
inline void carrierOn()  { tone(TX_PIN, CARRIER_HZ); }
inline void carrierOff() { noTone(TX_PIN); }

// Morse helpers
void sendDot()  { carrierOn(); delay(UNIT_MS * 1); carrierOff(); delay(UNIT_MS * 1); }
void sendDash() { carrierOn(); delay(UNIT_MS * 3); carrierOff(); delay(UNIT_MS * 1); }
// End-of-letter gap: total 3u OFF; we already did 1u after last element → add 2u
void letterGap() { delay(UNIT_MS * 2); }

void sendPattern(const char* pattern) {
  for (const char* p = pattern; *p; ++p) {
    if (*p == '.')      sendDot();
    else if (*p == '-') sendDash();
  }
  letterGap();
}

char decodeMorse(const String& code) {
  for (size_t i = 0; i < MORSE_TABLE_SIZE; ++i) {
    if (code.equals(MORSE_TABLE[i].code)) return MORSE_TABLE[i].ch;
  }
  return '?';
}

// Morse state
String   currentPattern = "";
uint32_t lastInputMs    = 0;
bool     lastDotLevel   = HIGH, lastDashLevel  = HIGH;
uint32_t lastDotChangeMs = 0,  lastDashChangeMs = 0;
bool     showingFinalChar = false;      // when true, first next press clears screen/pattern

// ---------------- Servo ----------------
const uint8_t SERVO_PIN     = 9;   // Servo signal
const uint8_t BTN_LEFT_PIN  = 6;   // to GND, INPUT_PULLUP
const uint8_t BTN_RIGHT_PIN = 7;   // to GND, INPUT_PULLUP

const int START_POS_DEG = 90;
const int STEP_DEG      = 10;       // ±10° per press
const int MIN_DEG       = 0;
const int MAX_DEG       = 180;

// Debounce (Servo)
const uint16_t DEBOUNCE_MS_SERVO = 25;

Servo servo;
int currentPos = START_POS_DEG;
bool lastLeft = HIGH, lastRight = HIGH;
uint32_t lastLeftChangeMs = 0, lastRightChangeMs = 0;

static inline int clamp(int v, int lo, int hi){ return (v<lo)?lo : (v>hi)?hi : v; }

// ---------------- LCD ----------------
LiquidCrystal_I2C lcd(0x27, 16, 2); // change to 0x3F if needed

void lcdClearBoth() {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Morse TX");
  lcd.setCursor(0,1);
}

void lcdShowPattern() {
  // line 1: only the dots/dashes being typed
  String msg = currentPattern;
  if (msg.length() > 16) msg = msg.substring(msg.length() - 16);
  // write padded
  String pad = msg; while (pad.length() < 16) pad += ' ';
  lcd.setCursor(0,1); lcd.print(pad);
}

void lcdShowChar(char ch) {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Sent:");
  lcd.setCursor(6,0);
  lcd.print(ch);
  // leave second line blank
}

// ---------------- Setup ----------------
void setup() {
  Serial.begin(115200);

  // IR/Morse
  pinMode(TX_PIN, OUTPUT);
  carrierOff();
  pinMode(DOT_PIN,  INPUT_PULLUP);
  pinMode(DASH_PIN, INPUT_PULLUP);
  lastInputMs = millis();

  // Servo
  pinMode(BTN_LEFT_PIN,  INPUT_PULLUP);
  pinMode(BTN_RIGHT_PIN, INPUT_PULLUP);
  servo.attach(SERVO_PIN);
  currentPos = clamp(START_POS_DEG, MIN_DEG, MAX_DEG);
  servo.write(currentPos);

  // LCD
  lcd.init();
  lcd.backlight();
  lcdClearBoth();

  Serial.println("TX ready: DOT=D4, DASH=D5, LEFT=D6, RIGHT=D7, Servo=D9, IR=D3, LCD=0x27.");
}

// ---------------- Loop ----------------
void loop() {
  const uint32_t now = millis();

  // If we previously showed a finalized character, clear for new pattern on first new press
  auto prepareForNewPatternIfNeeded = [&](){
    if (showingFinalChar) {
      showingFinalChar = false;
      currentPattern = "";
      lcdClearBoth();
    }
  };

  // ===== Morse: DOT (active LOW) with debounce =====
  bool dotLevel = digitalRead(DOT_PIN);
  if (dotLevel != lastDotLevel) {
    if (now - lastDotChangeMs >= DEBOUNCE_MS_MORSE) {
      lastDotChangeMs = now;
      lastDotLevel = dotLevel;
      if (dotLevel == LOW) {
        prepareForNewPatternIfNeeded();
        currentPattern += '.';
        lastInputMs = now;
        Serial.print("DOT -> "); Serial.println(currentPattern);
        lcdShowPattern();
      }
    }
  }

  // ===== Morse: DASH (active LOW) with debounce =====
  bool dashLevel = digitalRead(DASH_PIN);
  if (dashLevel != lastDashLevel) {
    if (now - lastDashChangeMs >= DEBOUNCE_MS_MORSE) {
      lastDashChangeMs = now;
      lastDashLevel = dashLevel;
      if (dashLevel == LOW) {
        prepareForNewPatternIfNeeded();
        currentPattern += '-';
        lastInputMs = now;
        Serial.print("DASH -> "); Serial.println(currentPattern);
        lcdShowPattern();
      }
    }
  }

  // ===== Morse: finalize and transmit after idle > 2s =====
  if (currentPattern.length() > 0 && (now - lastInputMs) > END_CHAR_IDLE_MS) {
    char ch = decodeMorse(currentPattern);
    Serial.print("Finalize: "); Serial.print(currentPattern); Serial.print(" -> "); Serial.println(ch);

    // Transmit exactly what was typed
    sendPattern(currentPattern.c_str());

    // After transmit, clear pattern display and show resulting character
    lcdShowChar(ch);
    showingFinalChar = true;

    currentPattern = "";
  }

  // ===== Servo: LEFT (active LOW) one-step-per-press (no LCD output) =====
  bool leftLevel = digitalRead(BTN_LEFT_PIN);
  if (leftLevel != lastLeft && (now - lastLeftChangeMs) >= DEBOUNCE_MS_SERVO) {
    lastLeftChangeMs = now;
    lastLeft = leftLevel;
    if (leftLevel == LOW) {
      currentPos = clamp(currentPos - STEP_DEG, MIN_DEG, MAX_DEG);
      servo.write(currentPos);
      Serial.print("LEFT press → "); Serial.print(currentPos); Serial.println("°");
    }
  }

  // ===== Servo: RIGHT (active LOW) one-step-per-press (no LCD output) =====
  bool rightLevel = digitalRead(BTN_RIGHT_PIN);
  if (rightLevel != lastRight && (now - lastRightChangeMs) >= DEBOUNCE_MS_SERVO) {
    lastRightChangeMs = now;
    lastRight = rightLevel;
    if (rightLevel == LOW) {
      currentPos = clamp(currentPos + STEP_DEG, MIN_DEG, MAX_DEG);
      servo.write(currentPos);
      Serial.print("RIGHT press → "); Serial.print(currentPos); Serial.println("°");
    }
  }

  delay(2);
}
